[{"name":"Hidden Input","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    actionVariableId: name,\n    value\n  } = options;\n  const isDev = B.env === 'dev';\n\n  if (isDev) {\n    return <div className={classes.dev}>Hidden input</div>;\n  }\n\n  function Input() {\n    return <input className={[isDev ? classes.dev : ''].join(' ')} defaultValue={B.useText(value)} id={name} name={name} type=\"hidden\" />;\n  }\n\n  return <Input />;\n})()","styles":"() => () => ({\n  root: {\n    '& > *': {\n      pointerEvents: 'none'\n    }\n  },\n  dev: {\n    borderWidth: '0.0625rem',\n    borderColor: '#AFB5C8',\n    borderStyle: 'dashed',\n    backgroundColor: '#F0F1F5',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    minHeight: '2rem',\n    width: '100%',\n    fontSize: '0.75rem',\n    color: '#262A3A',\n    textTransform: 'uppercase',\n    boxSizing: 'border-box',\n    textAlign: 'center'\n  }\n})","functions":[],"triggers":[],"interactions":{},"componentHash":"0a72a2a7cd8ee9d35adedd65d1a91daa7ff4fb6cc014e4fc7bd71b621bbcdb4e"},{"name":"DataTable Filter","type":"CONTENT_COMPONENT","allowedTypes":["DATATABLE_COLUMN"],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    Children,\n    env,\n    getProperty,\n    GetMe,\n    InteractionScope,\n    ModelProvider,\n    useAllQuery,\n    useFilter,\n    useText\n  } = B;\n  const {\n    Table,\n    TableBody,\n    TableContainer,\n    TableHead,\n    TableRow,\n    TableCell,\n    TablePagination,\n    Paper,\n    Toolbar,\n    TextField,\n    InputAdornment,\n    Checkbox,\n    Tooltip\n  } = window.MaterialUI.Core;\n  const {\n    Search,\n    CheckBoxOutlineBlank,\n    CheckBox,\n    IndeterminateCheckBox\n  } = window.MaterialUI.Icons;\n  const isDev = env === 'dev';\n  const {\n    take,\n    placeholderTake,\n    size,\n    model,\n    authProfile,\n    filter,\n    searchProperty,\n    hideSearch,\n    orderProperty,\n    sortOrder,\n    labelRowsPerPage,\n    labelNumberOfPages,\n    labelSearchOn,\n    square,\n    striped,\n    elevation,\n    variant,\n    stickyHeader,\n    title,\n    pagination,\n    showError,\n    autoLoadOnScroll,\n    autoLoadTakeAmount,\n    filterTimeout,\n    rowSelection,\n    labelRowsSelection,\n    checkboxSize,\n    checkboxColor,\n    showTextTooltip // rowClick,\n    // linkTo,\n    // linkType,\n    // linkToExternal,\n\n  } = options;\n  const repeaterRef = React.createRef();\n  const tableRef = React.createRef();\n  const tableContainerRef = React.createRef();\n  const displayError = showError === 'built-in';\n  const [page, setPage] = useState(0);\n  const takeNum = parseInt(take, 10);\n  const initialRender = useRef(true);\n  const skipAppend = useRef(false);\n  const [skip, setSkip] = useState(0);\n  const loadOnScroll = pagination === 'never' && autoLoadOnScroll;\n  const autoLoadTakeAmountNum = parseInt(autoLoadTakeAmount, 10);\n  const [rowsPerPage, setRowsPerPage] = useState(takeNum);\n  const [search, setSearch] = useState('');\n  const [searchTerm, setSearchTerm] = useState('');\n  const [interactionSearchTerm, setInteractionSearchTerm] = useState('');\n  const [interactionSearchProperty, setInteractionSearchProperty] = useState('');\n  const [startFiltering, setStartFiltering] = useState('');\n  const [previousInteractionSearchTerm, setPreviousInteractionSearchTerm] = useState('');\n  const [previousInteractionSearchProperty, setPreviousInteractionSearchProperty] = useState('');\n  const [showPagination, setShowPagination] = useState(false);\n  const [interactionFilter, setInteractionFilter] = useState({});\n  const {\n    label: searchPropertyLabel = '{property}'\n  } = getProperty(searchProperty) || {};\n  let orderPropertyPath = null;\n\n  if (orderProperty && Array.isArray(orderProperty.id)) {\n    orderPropertyPath = orderProperty.id;\n  } else if (orderProperty && orderProperty.id) {\n    orderPropertyPath = [orderProperty.id];\n  }\n\n  const [orderBy, setOrderBy] = React.useState({\n    field: orderPropertyPath,\n    order: orderProperty ? sortOrder : null\n  });\n  const [results, setResults] = useState([]);\n  const [totalCount, setTotalCount] = useState(0);\n  const [previousSearchTerm, setPreviousSearchTerm] = useState('');\n  const [newSearch, setNewSearch] = useState(false);\n  const fetchingNextSet = useRef(false);\n  const [initialTimesFetched, setInitialTimesFetched] = useState(0);\n  const amountOfRows = loadOnScroll ? autoLoadTakeAmountNum : rowsPerPage;\n  const [storedData, setStoredData] = useState();\n  const [firstLoad, setFirstLoad] = useState(true);\n  const [selectedValues, setSelectedValues] = useState([]);\n  const [selectedAllValues, setSelectedAllValues] = useState(false);\n  const possibleSelectionValues = [];\n\n  const createSortObject = (fields, order) => {\n    const sort = fields.reduceRight((acc, property, index) => {\n      const prop = getProperty(property);\n      return index === fields.length - 1 ? {\n        [prop.name]: order.toUpperCase()\n      } : {\n        [prop.name]: acc\n      };\n    }, {});\n    return sort;\n  };\n\n  const [variables, setVariables] = useState(orderPropertyPath ? {\n    sort: {\n      relation: !isDev && createSortObject(orderPropertyPath, sortOrder)\n    }\n  } : {});\n  const titleText = useText(title);\n  const hasToolbar = titleText || searchProperty && !hideSearch;\n  const elevationLevel = variant === 'flat' ? 0 : elevation;\n  const toolbarRef = React.createRef();\n  const paginationRef = React.createRef();\n  const [stylesProps, setStylesProps] = useState(null);\n\n  const deepMerge = (...objects) => {\n    const isObject = item => item && typeof item === 'object' && !Array.isArray(item);\n\n    return objects.reduce((accumulator, object) => {\n      Object.keys(object).forEach(key => {\n        const accumulatorValue = accumulator[key];\n        const value = object[key];\n\n        if (Array.isArray(accumulatorValue) && Array.isArray(value)) {\n          accumulator[key] = accumulatorValue.concat(value);\n        } else if (isObject(accumulatorValue) && isObject(value)) {\n          accumulator[key] = deepMerge(accumulatorValue, value);\n        } else {\n          accumulator[key] = value;\n        }\n      });\n      return accumulator;\n    }, {});\n  };\n\n  let path = [searchProperty].flat();\n\n  if (typeof searchProperty.id !== 'undefined') {\n    path = [searchProperty.id].flat();\n  }\n\n  const transformValue = value => {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n\n    return value;\n  };\n  /**\n   * @name Filter\n   * @param {Property} property\n   * @returns {Void}\n   */\n  // eslint-disable-next-line prettier/prettier\n\n\n  B.defineFunction('Filtering', filterArray => {\n    setStartFiltering(filterArray);\n  });\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      const event = startFiltering[1];\n      const property = startFiltering[0];\n      const interactionId = startFiltering[2];\n      if (typeof event === 'undefined') return;\n      setInteractionFilter({ ...interactionFilter,\n        [interactionId]: {\n          property,\n          value: event.target ? event.target.value : transformValue(event)\n        }\n      });\n      setInteractionSearchTerm(event.target ? event.target.value : transformValue(event));\n      setInteractionSearchProperty(property ? property.id : '');\n    }, filterTimeout);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [startFiltering]);\n  B.defineFunction('ResetFilter', () => {\n    setInteractionFilter({});\n    setInteractionSearchTerm('');\n    setInteractionSearchProperty('');\n  });\n  let interactionFilters = {};\n\n  const isEmptyValue = value => !value || Array.isArray(value) && value.length === 0; // const processValue = value =>\n  //   Object.entries(value)\n  //     // .filter(([, { value2 }]) => !isEmptyValue(value2))\n  //     .map(([, { property, value }]) =>\n  //       property.id.reduceRight((acc, field, index, arr) => {\n  //         const isLast = index === arr.length - 1;\n  //         if (isLast) {\n  //           return { [field]: { [property.operator]: value } };\n  //         }\n  //         // this is where the first layer(s) are put\n  //         return { [field]: acc };\n  //       }, {}),\n  //     );\n\n\n  const processValue = (value, property, field) => ({\n    [field]: {\n      [property.operator]: value\n    }\n  });\n\n  const processArray = (value, property, field) => ({\n    _or: value.map(el => processValue(el, property, field))\n  });\n\n  const processObjects = (value, property, field) => ({\n    _and: value.map(el => Array.isArray(el.and) ? processArray(el.and, property, field) : processValue(el.and, property, field))\n  });\n\n  const clauses = Object.entries(interactionFilter).filter(([, {\n    value\n  }]) => !isEmptyValue(value)).map(([, {\n    property,\n    value\n  }]) => property.id.reduceRight((acc, field, index, arr) => {\n    const isLast = index === arr.length - 1;\n\n    if (isLast && Array.isArray(value) && !value[0].and) {\n      return processArray(value, property, field);\n    }\n\n    if (isLast && Array.isArray(value)) {\n      return processObjects(value, property, field);\n    } // if (Array.isArray(value) && !value[0].and) {\n    //   const key = '_and';\n    //   return { key: { [field]: acc } };\n    // }\n    // if (Array.isArray(value)) {\n    //   const key = '_or';\n    //   return { key: { [field]: acc } };\n    // }\n\n\n    if (isLast) {\n      return processValue(value, property, field);\n    }\n\n    return {\n      [field]: acc\n    };\n  }, {}));\n  interactionFilters = clauses.length > 1 ? {\n    _and: clauses\n  } : clauses[0] || {};\n  const searchFilter = searchProperty ? path.reduceRight((acc, property, index) => index === path.length - 1 ? {\n    [property]: {\n      matches: searchTerm\n    }\n  } : {\n    [property]: acc\n  }, {}) : {};\n  const newFilter = searchProperty && searchTerm !== '' ? deepMerge(filter, searchFilter) : filter;\n  const completeFilter = deepMerge(newFilter, interactionFilters);\n  const where = useFilter(completeFilter); // TODO: move model to skip\n\n  const {\n    loading,\n    error,\n    data,\n    refetch\n  } = useAllQuery(model, {\n    rawFilter: where,\n    variables,\n    skip: loadOnScroll ? skip : page * rowsPerPage,\n    take: loadOnScroll ? autoLoadTakeAmountNum : rowsPerPage,\n\n    onCompleted(res) {\n      const hasResult = res && res.results && res.results.length > 0;\n\n      if (!firstLoad) {\n        // eslint-disable-next-line object-shorthand\n        const storageResults = {\n          data: data,\n          key: 'storedResults'\n        };\n        B.triggerEvent('SetLocalStorage', storageResults);\n        const storageFilters = {\n          data: interactionFilter,\n          key: 'storedFilters'\n        };\n        const logging = {\n          storageResults,\n          storageFilters\n        }; // console.log(logging);\n\n        B.triggerEvent('SetLogging', logging);\n        B.triggerEvent('SetLocalStorage', storageFilters);\n      } else {\n        setFirstLoad(false);\n      }\n\n      if (hasResult) {\n        B.triggerEvent('onSuccess', res.results);\n      } else {\n        B.triggerEvent('onNoResults');\n      }\n    },\n\n    onError(err) {\n      if (!displayError) {\n        B.triggerEvent('onError', err);\n      }\n    }\n\n  });\n  useEffect(() => {\n    if (!isDev && storedData) {\n      // Not sure if this one's actually fired or useful, second call is made anyway\n      if (pagination !== 'never') {\n        setResults(storedData.results);\n        setTotalCount(storedData.totalCount);\n        return;\n      }\n\n      setResults(storedData.results);\n      setNewSearch(false);\n      setTotalCount(storedData.totalCount);\n    } else if (!isDev && data) {\n      if (pagination !== 'never') {\n        setResults(data.results);\n        setTotalCount(data.totalCount);\n        return;\n      }\n\n      if (searchTerm !== previousSearchTerm || interactionSearchTerm !== previousInteractionSearchTerm || interactionSearchProperty !== previousInteractionSearchProperty) {\n        setSkip(0);\n        setInitialTimesFetched(0);\n        setPreviousSearchTerm(searchTerm);\n        setPreviousInteractionSearchTerm(interactionSearchTerm);\n        setPreviousInteractionSearchProperty(interactionSearchProperty);\n        setNewSearch(true);\n      } else {\n        if (newSearch || !autoLoadOnScroll && skipAppend.current || pagination === 'never' && !autoLoadOnScroll) {\n          setResults(data.results);\n        } else {\n          setResults(prev => [...prev, ...data.results]);\n        }\n\n        fetchingNextSet.current = false;\n        setNewSearch(false);\n      }\n\n      skipAppend.current = false;\n      setTotalCount(data.totalCount);\n    }\n  }, [data, storedData, searchTerm, interactionSearchTerm, interactionSearchProperty]);\n  useEffect(() => {\n    if (!isDev && data) {\n      if (pagination !== 'never') {\n        setResults(data.results);\n        setTotalCount(data.totalCount);\n        return;\n      }\n\n      if (searchTerm !== previousSearchTerm) {\n        setSkip(0);\n        setInitialTimesFetched(0);\n        setPreviousSearchTerm(searchTerm);\n        setNewSearch(true);\n      } else {\n        if (newSearch || !autoLoadOnScroll && skipAppend.current) {\n          setResults(data.results);\n        } else {\n          setResults(prev => [...prev, ...data.results]);\n        }\n\n        fetchingNextSet.current = false;\n        setNewSearch(false);\n      }\n\n      skipAppend.current = false;\n      setTotalCount(data.totalCount);\n    }\n  }, [data, searchTerm]);\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setSearchTerm(search);\n    }, filterTimeout);\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [search]);\n\n  function clearResults() {\n    setInitialTimesFetched(0);\n    setResults([]);\n    setTimeout(() => {\n      setSkip(0);\n    }, 0);\n  }\n\n  B.defineFunction('Refetch', () => {\n    if (pagination === 'never') {\n      clearResults();\n      skipAppend.current = true;\n      setTimeout(() => {\n        refetch();\n      }, 0);\n    } else {\n      refetch();\n    }\n  });\n  B.defineFunction('SetSearchValue', event => {\n    setSearch(event.target.value);\n  });\n  B.defineFunction('GetStoredObjectTriggerTest', () => {\n    B.triggerEvent('GetStoredObject', ['storedResults', 'storedFilters']);\n  });\n  B.defineFunction('GotStoredObject', storedObject => {\n    if (Object.keys(storedObject)[0] === 'results') {\n      setStoredData(storedObject);\n    } else {\n      setInteractionFilter(storedObject);\n    }\n  });\n  B.defineFunction('ResetRowSelection', () => {\n    setSelectedValues([]);\n  });\n  useEffect(() => {\n    if (!isDev) return;\n    const placeholders = placeholderTake || amountOfRows;\n\n    const repeat = () => {\n      if (!repeaterRef.current) return;\n\n      if (repeaterRef.current.previousElementSibling.children.length === 0) {\n        return;\n      }\n\n      repeaterRef.current.innerHTML = '';\n\n      for (let i = 0, j = placeholders - 1; i < j; i += 1) {\n        repeaterRef.current.innerHTML += repeaterRef.current.previousElementSibling.children[0].outerHTML;\n      }\n\n      if (striped) {\n        const childrenLenght = children.length;\n        const collection = Array.from(repeaterRef.current.children);\n        collection.filter(item => item.tagName === 'DIV').forEach((item, index) => {\n          if (Math.ceil((index + 1) / childrenLenght) * childrenLenght / childrenLenght % 2 === 0) {\n            item.classList.add('striped');\n          }\n        });\n      }\n    };\n\n    const mutationObserver = new MutationObserver(() => {\n      repeat();\n    });\n    mutationObserver.observe(tableRef.current, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n      attributeOldValue: false,\n      characterDataOldValue: false\n    });\n    repeat();\n  });\n  useEffect(() => {\n    setRowsPerPage(takeNum);\n  }, [takeNum]);\n  const mounted = useRef(false);\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n  useEffect(() => {\n    if (mounted.current && loading) {\n      B.triggerEvent('onLoad', loading);\n    }\n  }, [loading]);\n  useEffect(() => {\n    B.triggerEvent('onRowSelection', selectedValues);\n    if (selectedValues.length === 0) B.triggerEvent('onNoRowSelected');\n\n    if (selectedValues.length > 0 && selectedValues.sort().toString() === possibleSelectionValues.sort().toString()) {\n      setSelectedAllValues(true);\n    } else {\n      setSelectedAllValues(false);\n    }\n  }, [selectedValues]);\n\n  const handleChangePage = (_, newPage) => {\n    if (loading || error) return;\n    setPage(newPage);\n  };\n\n  const handleChangeRowsPerPage = event => {\n    if (loading || error) return;\n    setRowsPerPage(parseInt(event.target.value, 10));\n    setPage(0);\n  };\n\n  const handleSort = (field, newOrder) => {\n    if (isDev) return;\n    setOrderBy({\n      field,\n      order: newOrder\n    });\n    setVariables({\n      sort: {\n        relation: createSortObject(field, newOrder)\n      }\n    });\n  };\n\n  const handleSearch = event => {\n    setSearch(event.target.value);\n  }; // const handleRowClick = (endpoint, context) => {\n  //   if (isDev) return;\n  //   B.triggerEvent('OnRowClick', endpoint, context);\n  //   window.top.location.href = endpoint;\n  // };\n\n\n  const handleSelection = (e, data) => {\n    let currentValues = [...selectedValues];\n\n    if (e.target.checked) {\n      currentValues.push(data.id);\n      setSelectedValues(currentValues);\n    } else {\n      const index = currentValues.indexOf(data.id);\n\n      if (index !== -1) {\n        currentValues.splice(index, 1);\n        setSelectedValues(currentValues);\n      }\n    }\n  };\n\n  const handleAllSelection = e => {\n    if (selectedValues.sort().toString() !== possibleSelectionValues.sort().toString()) {\n      setSelectedValues(possibleSelectionValues);\n      setSelectedAllValues(true);\n    } else {\n      setSelectedValues([]);\n      setSelectedAllValues(false);\n    }\n  };\n\n  const renderTableHead = () => {\n    if (loading && !loadOnScroll || error) {\n      return Array.from(Array(children.length).keys()).map(colIdx => <TableCell key={colIdx}>\n            <div className={classes.skeleton}>\n              {error && displayError && error.message}\n            </div>\n          </TableCell>);\n    }\n\n    return <Children headerOnly handleSort={handleSort} orderBy={orderBy}>\n          {children}\n        </Children>;\n  };\n\n  const tableContentModel = () => {\n    if (loading && !loadOnScroll || error) {\n      return Array.from(Array(rowsPerPage).keys()).map(idx => <TableRow key={idx} classes={{\n        root: classes.bodyRow\n      }}>\n            {Array.from(Array(children.length).keys()).map(colIdx => <TableCell key={colIdx}>\n                <div className={classes.skeleton} />\n              </TableCell>)}\n          </TableRow>);\n    }\n\n    const rows = results.map(value => {\n      possibleSelectionValues.push(value.id);\n      return <ModelProvider value={value} id={model}>\n            <InteractionScope model={model}>\n              {context => <TableRow key={value[0]} classes={{\n            root: classes.bodyRow\n          }} data-id={value.id}>\n                  {rowSelection && <TableCell className={classes.rowSelectionCell} key={`rs-${value.id}`}>\n                      <Checkbox icon={<CheckBoxOutlineBlank className={classes.rowCheckbox} />} checkedIcon={<CheckBox className={classes.rowCheckbox} />} onChange={e => handleSelection(e, value)} checked={selectedValues.includes(value.id)} />\n                    </TableCell>}\n                  <Children // rowClick={rowClick}\n            // linkType={linkType}\n            // linkTo={linkTo || linkToExternal}\n            // handleRowClick={handleRowClick}\n            showTextTooltip={showTextTooltip} context={context}>\n                    {children}\n                  </Children>\n                </TableRow>}\n            </InteractionScope>\n          </ModelProvider>;\n    });\n\n    if (authProfile) {\n      return <GetMe authenticationProfileId={authProfile}>{rows}</GetMe>;\n    }\n\n    return rows;\n  };\n\n  const renderTableContent = () => {\n    if (isDev) {\n      return <TableRow classes={{\n        root: classes.bodyRow\n      }}>{children}</TableRow>;\n    }\n\n    if (model) {\n      return tableContentModel();\n    }\n\n    return Array.from(Array(amountOfRows).keys()).map(idx => <TableRow key={idx} classes={{\n      root: classes.bodyRow\n    }}>\n          {rowSelection && <TableCell className={classes.rowCheckboxCell}>\n              <Checkbox icon={<CheckBoxOutlineBlank className={classes.rowCheckbox} />} checkedIcon={<CheckBox className={classes.rowCheckbox} />} />\n            </TableCell>}\n          {children}\n        </TableRow>);\n  };\n\n  useEffect(() => {\n    if (loadOnScroll && !isDev) {\n      const fetchNextSet = () => {\n        fetchingNextSet.current = true;\n\n        if (!initialRender.current) {\n          setSkip(prev => prev + autoLoadTakeAmountNum);\n        }\n\n        initialRender.current = false;\n      };\n\n      const tableContainerElement = tableContainerRef.current;\n\n      if (loadOnScroll) {\n        const parent = tableContainerElement.parentNode;\n\n        if (tableContainerElement.scrollHeight <= parent.clientHeight && initialTimesFetched < 5) {\n          setInitialTimesFetched(prev => prev + 1);\n          fetchNextSet();\n        }\n\n        const scrollEvent = e => {\n          const {\n            scrollTop,\n            clientHeight,\n            scrollHeight\n          } = e.target;\n          const offset = scrollHeight / 5;\n          const hitBottom = scrollTop + clientHeight >= scrollHeight - offset;\n\n          if (hitBottom && !fetchingNextSet.current) {\n            fetchNextSet();\n          }\n        };\n\n        tableContainerElement.addEventListener('scroll', scrollEvent);\n      }\n    }\n  }, [results]);\n  useEffect(() => {\n    if (pagination === 'never') {\n      const dataResults = data && data.results;\n      const needsCacheFix = results.length === 0 && dataResults && dataResults.length > 0;\n\n      const setExistingData = () => {\n        setResults(dataResults);\n        fetchingNextSet.current = false;\n      };\n\n      if (needsCacheFix && !autoLoadOnScroll) {\n        setExistingData();\n      }\n\n      if (needsCacheFix && autoLoadOnScroll && skip === 0) {\n        setExistingData();\n      }\n\n      if (needsCacheFix && autoLoadOnScroll && skip !== 0) {\n        setSkip(0);\n      }\n    }\n  }, [results]);\n  useEffect(() => {\n    if (isDev) {\n      if (pagination === 'never') {\n        setShowPagination(false);\n      } else {\n        setShowPagination(true);\n      }\n    }\n  }, [pagination]);\n  useEffect(() => {\n    if (!isDev && data) {\n      switch (pagination) {\n        case 'never':\n          setShowPagination(false);\n          break;\n\n        case 'whenNeeded':\n          if (rowsPerPage >= data.totalCount) {\n            setShowPagination(false);\n          } else {\n            setShowPagination(true);\n          }\n\n          break;\n\n        default:\n        case 'always':\n          setShowPagination(true);\n          break;\n      }\n    }\n  }, [data, rowsPerPage]);\n  useEffect(() => {\n    let amount = 0;\n\n    if (hasToolbar) {\n      amount += toolbarRef.current.clientHeight;\n    }\n\n    if (showPagination) {\n      amount += paginationRef.current.clientHeight;\n    }\n\n    let style;\n\n    if (amount > 0 || !hasToolbar) {\n      style = {\n        height: `calc(100% - ${amount}px)`,\n        borderRadius: `${hasToolbar ? '0rem' : '0.1875rem'}`\n      };\n      setStylesProps({\n        style\n      });\n    } else {\n      setStylesProps(null);\n    }\n  }, [showPagination, hasToolbar]);\n  return <div className={classes.root}>\n        <Paper classes={{\n      root: classes.paper\n    }} square={square} variant={variant} elevation={elevationLevel}>\n          {hasToolbar && <Toolbar ref={toolbarRef} classes={{\n        root: classes.toolbar\n      }}>\n              {titleText && <span className={classes.title}>{titleText}</span>}\n              {searchProperty && !hideSearch && <TextField classes={{\n          root: classes.searchField\n        }} placeholder={`${useText(labelSearchOn)} ${searchPropertyLabel}`} InputProps={{\n          startAdornment: <InputAdornment position=\"start\">\n                        <Search />\n                      </InputAdornment>\n        }} onChange={handleSearch} />}\n            </Toolbar>}\n          <TableContainer ref={tableContainerRef} classes={{\n        root: classes.container\n      }} {...stylesProps}>\n            <Table stickyHeader={stickyHeader} size={size} classes={{\n          root: classes.tableRoot\n        }}>\n              <TableHead>\n                <TableRow classes={{\n              root: classes.headerRow\n            }}>\n                  {!isDev && rowSelection && <TableCell className={classes.rowCheckboxCell}>\n                      <Checkbox icon={<CheckBoxOutlineBlank className={classes.rowCheckbox} />} checkedIcon={<CheckBox className={classes.rowCheckbox} />} checked={selectedAllValues} onChange={e => handleAllSelection(e)} />\n                    </TableCell>}\n                  {renderTableHead()}\n                </TableRow>\n              </TableHead>\n              <TableBody ref={tableRef}>{renderTableContent()}</TableBody>\n              {isDev && <TableBody ref={repeaterRef} className={classes.autoRepeat} />}\n            </Table>\n          </TableContainer>\n          {showPagination && <>\n              {isDev && rowSelection && <span className={classes.rowsSelectedLabel}>\n                  # {labelRowsSelection}\n                </span>}\n              {!isDev && rowSelection && selectedValues.length > 0 && <span className={classes.rowsSelectedLabel}>\n                  {selectedValues.length} {labelRowsSelection}\n                </span>}\n              <TablePagination ref={paginationRef} classes={{\n          root: classes.pagination\n        }} rowsPerPageOptions={[5, 10, 25, 50, 100]} labelRowsPerPage={useText(labelRowsPerPage)} labelDisplayedRows={({\n          from,\n          to,\n          count\n        }) => `${from}-${to} ${useText(labelNumberOfPages)} ${count}`} component=\"div\" count={model ? totalCount : takeNum} rowsPerPage={model ? rowsPerPage : takeNum} page={page} onChangePage={handleChangePage} onChangeRowsPerPage={handleChangeRowsPerPage} />\n            </>}\n        </Paper>\n      </div>;\n})()","styles":"B => theme => {\n  const {\n    env,\n    mediaMinWidth,\n    Styling\n  } = B;\n  const style = new Styling(theme);\n  const isDev = env === 'dev';\n\n  const getSpacing = (idx, device = 'Mobile') => idx === '0' ? '0rem' : style.getSpacing(idx, device);\n\n  return {\n    root: {\n      marginTop: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[0]),\n      marginRight: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[1]),\n      marginBottom: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[2]),\n      marginLeft: ({\n        options: {\n          outerSpacing\n        }\n      }) => getSpacing(outerSpacing[3]),\n      height: ({\n        options: {\n          height\n        }\n      }) => height\n    },\n    paper: {\n      backgroundColor: ({\n        options: {\n          background\n        }\n      }) => [style.getColor(background), '!important'],\n      height: '100%'\n    },\n    container: {\n      height: '100%'\n    },\n    tableRoot: {\n      tableLayout: 'fixed',\n      '& .MuiCheckbox-root': {\n        color: ({\n          options: {\n            checkboxColor\n          }\n        }) => [style.getColor(checkboxColor), '!important'],\n        padding: '0 !important'\n      },\n      '& .MuiCheckbox-root.Mui-checked': {\n        color: ({\n          options: {\n            checkboxColorChecked\n          }\n        }) => [style.getColor(checkboxColorChecked), '!important']\n      },\n      '& .MuiCheckbox-root.MuiIconButton-root:hover': {\n        backgroundColor: 'rgba(0, 0, 0, 0.04) !important'\n      }\n    },\n    toolbar: {\n      paddingLeft: ['1rem', '!important'],\n      paddingRight: ['1rem', '!important']\n    },\n    rowCheckboxCell: {\n      width: ({\n        options: {\n          checkboxSize\n        }\n      }) => `${checkboxSize} !important`\n    },\n    rowCheckbox: {\n      fontSize: ({\n        options: {\n          checkboxSize\n        }\n      }) => `${checkboxSize} !important`\n    },\n    rowsSelectedLabel: {\n      position: 'absolute',\n      marginTop: 26,\n      marginLeft: 20,\n      fontSize: '0.875rem',\n      letterSpacing: '.01071em',\n      lineHeight: 0\n    },\n    title: {\n      color: ({\n        options: {\n          titleType\n        }\n      }) => style.getFontColor(titleType),\n      fontFamily: ({\n        options: {\n          titleType\n        }\n      }) => style.getFontFamily(titleType),\n      fontSize: ({\n        options: {\n          titleType\n        }\n      }) => style.getFontSize(titleType),\n      fontWeight: ({\n        options: {\n          titleType\n        }\n      }) => style.getFontWeight(titleType),\n      textTransform: ({\n        options: {\n          titleType\n        }\n      }) => style.getTextTransform(titleType),\n      letterSpacing: ({\n        options: {\n          titleType\n        }\n      }) => style.getLetterSpacing(titleType),\n      lineHeight: '1.2',\n      [`@media ${mediaMinWidth(600)}`]: {\n        fontSize: ({\n          options: {\n            titleType\n          }\n        }) => style.getFontSize(titleType, 'Portrait')\n      },\n      [`@media ${mediaMinWidth(960)}`]: {\n        fontSize: ({\n          options: {\n            titleType\n          }\n        }) => style.getFontSize(titleType, 'Landscape')\n      },\n      [`@media ${mediaMinWidth(1280)}`]: {\n        fontSize: ({\n          options: {\n            titleType\n          }\n        }) => style.getFontSize(titleType, 'Desktop')\n      }\n    },\n    headerRow: {\n      backgroundColor: ({\n        options: {\n          backgroundHeader\n        }\n      }) => [style.getColor(backgroundHeader), '!important'],\n      '& div': {\n        borderBottom: `${isDev ? '0.0625rem solid #cccccc' : 0}`\n      },\n      '& th, & div[role=\"columnheader\"]': {\n        borderBottom: `${isDev ? 0 : '0.0625rem solid #cccccc!important'}`,\n        backgroundColor: ({\n          options: {\n            backgroundHeader\n          }\n        }) => [style.getColor(backgroundHeader), '!important']\n      },\n      '& > div > .MuiTableCell-head, & > .MuiTableCell-head': {\n        textOverflow: ({\n          options: {\n            hideTextOverflow\n          }\n        }) => hideTextOverflow ? 'ellipsis' : 'clip',\n        overflow: ({\n          options: {\n            hideTextOverflow\n          }\n        }) => hideTextOverflow ? 'hidden' : 'visible',\n        whiteSpace: ({\n          options: {\n            hideTextOverflow\n          }\n        }) => hideTextOverflow ? 'nowrap' : 'normal',\n        // padding: ({ options: { rowPaddingX, rowPaddingY } }) =>\n        //   `clamp(9px, ${rowPaddingY}, 64px) clamp(9px, ${rowPaddingX}, 64px)`,\n        padding: ({\n          options: {\n            rowPaddingX,\n            rowPaddingY\n          }\n        }) => `${rowPaddingY} ${rowPaddingX} ${rowPaddingY} ${rowPaddingX}`\n      }\n    },\n    bodyRow: {\n      // cursor: ({ options: { linkTo } }) =>\n      //   linkTo && linkTo.id !== '' && 'pointer',\n      // '&:hover td': {\n      //   cursor: 'pointer',\n      //   backgroundColor: ({ options: { linkTo, backgroundRowHover } }) =>\n      //     linkTo && [style.getColor(backgroundRowHover), '!important'],\n      // },\n      '&:nth-child(odd)': {\n        backgroundColor: ({\n          options: {\n            striped,\n            stripeColor\n          }\n        }) => [striped ? style.getColor(stripeColor) : 'transparent']\n      },\n      '& > .MuiTableCell-root, & ~ .MuiTableCell-root': {\n        textOverflow: ({\n          options: {\n            hideTextOverflow\n          }\n        }) => hideTextOverflow ? 'ellipsis' : 'clip',\n        overflow: ({\n          options: {\n            hideTextOverflow\n          }\n        }) => hideTextOverflow ? 'hidden' : 'visible',\n        whiteSpace: ({\n          options: {\n            hideTextOverflow\n          }\n        }) => hideTextOverflow ? 'nowrap' : 'normal',\n        padding: ({\n          options: {\n            rowPaddingX,\n            rowPaddingY\n          }\n        }) => `${rowPaddingY} ${rowPaddingX} ${rowPaddingY} ${rowPaddingX}`,\n        borderColor: ({\n          options: {\n            rowBorderColor\n          }\n        }) => [style.getColor(rowBorderColor), '!important']\n      }\n    },\n    searchField: {\n      marginLeft: ['auto', '!important'],\n      pointerEvents: isDev && 'none'\n    },\n    pagination: {\n      borderRadius: '0.1875rem',\n      pointerEvents: isDev && 'none',\n      backgroundColor: ({\n        options: {\n          background\n        }\n      }) => [style.getColor(background), '!important']\n    },\n    autoRepeat: {\n      opacity: 0.5,\n      '& .striped': {\n        background: ({\n          options: {\n            striped,\n            stripeColor\n          }\n        }) => [striped ? style.getColor(stripeColor) : 'transparent', '!important']\n      }\n    },\n    skeleton: {\n      height: `calc(${style.getFont('Body1').Mobile} * 1.2)`,\n      [`@media ${mediaMinWidth(600)}`]: {\n        height: `calc(${style.getFont('Body1').Portrait} * 1.2)`\n      },\n      [`@media ${mediaMinWidth(960)}`]: {\n        height: `calc(${style.getFont('Body1').Landscape} * 1.2)`\n      },\n      [`@media ${mediaMinWidth(1280)}`]: {\n        height: `calc(${style.getFont('Body1').Desktop} * 1.2)`\n      },\n      backgroundColor: '#eee',\n      borderRadius: 8,\n      overflow: 'hidden',\n      '&::after': {\n        display: 'block',\n        width: '100%',\n        height: '100%',\n        backgroundImage: 'linear-gradient(90deg, #eee 25%, #fff 50%, #eee 75%)',\n        backgroundSize: '200% 100%',\n        backgroundRepeat: 'no-repeat',\n        backgroundPositionX: '150%',\n        borderRadius: `calc(${style.getFont('Body2').Landscape} / 2)`,\n        content: '\"\"',\n        animation: 'loading 1.5s infinite'\n      }\n    },\n    '@keyframes loading': {\n      to: {\n        backgroundPositionX: '-150%'\n      }\n    },\n    [`@media ${mediaMinWidth(600)}`]: {\n      root: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Portrait'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Portrait'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Portrait'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Portrait')\n      }\n    },\n    [`@media ${mediaMinWidth(960)}`]: {\n      root: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Landscape'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Landscape'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Landscape'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Landscape')\n      }\n    },\n    [`@media ${mediaMinWidth(1280)}`]: {\n      root: {\n        marginTop: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[0], 'Desktop'),\n        marginRight: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[1], 'Desktop'),\n        marginBottom: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[2], 'Desktop'),\n        marginLeft: ({\n          options: {\n            outerSpacing\n          }\n        }) => getSpacing(outerSpacing[3], 'Desktop')\n      }\n    }\n  };\n}","functions":["Filtering","ResetFilter","Refetch","SetSearchValue","GetStoredObjectTriggerTest","GotStoredObject","ResetRowSelection"],"triggers":["SetLocalStorage","SetLogging","SetLocalStorage","onSuccess","onNoResults","onError","GetStoredObject","onLoad","onRowSelection","onNoRowSelected"],"interactions":{"Filter":{"parameters":{"property":["Property"]},"returnType":["Void"]}},"componentHash":"81c23c9f3f981ed69dbe0269ff8d437ad875df1086cf709611f49a378510e9d6"},{"name":"DataTableColumn","type":"DATATABLE_COLUMN","allowedTypes":["CONTENT_COMPONENT","CONTAINER_COMPONENT"],"orientation":"VERTICAL","jsx":"(() => {\n  const {\n    env,\n    getProperty,\n    Property,\n    useEndpoint,\n    useText\n  } = B;\n  const {\n    TableCell,\n    TableSortLabel,\n    Tooltip\n  } = window.MaterialUI.Core;\n  const {\n    horizontalAlignment,\n    headerText,\n    property,\n    content,\n    sortable\n  } = options; // eslint-disable-next-line prettier/prettier\n\n  const {\n    headerOnly,\n    handleSort,\n    orderBy,\n    showTextToolTip,\n    context // rowClick,\n    // linkTo,\n    // linkToExternal,\n    // linkType,\n    // handleRowClick,\n\n  } = parent || {};\n  const {\n    type,\n    id: propertyPath\n  } = property;\n  const {\n    kind,\n    name: propertyName,\n    label: propertyLabel\n  } = getProperty(property) || {};\n  const {\n    field,\n    order = 'asc'\n  } = orderBy || {};\n  const isDev = env === 'dev';\n  const isEmpty = children.length === 0;\n  const contentPlaceholder = isDev && isEmpty ? 'Select property' : '\\u00A0';\n  const isBooleanProperty = kind === 'boolean' || kind === 'BOOLEAN'; // Row click functionaliteit hebben we er voor nu uitgehaald wegen een onduidelijke bug\n  // let myEndpoint = null;\n  // if (rowClick) {\n  //   if (linkType === 'internal' && linkTo != '') {\n  //     myEndpoint = useEndpoint(linkTo);\n  //   } else if (linkType === 'external' && linkToExternal != '') {\n  //     myEndpoint = useText(linkToExternal);\n  //   }\n  // }\n\n  let checkboxStatus = '';\n  if (isBooleanProperty && useText([property])) checkboxStatus = useText([property]) === 'true' ? <span className={classes.checked} role=\"img\" aria-label=\"checked\">\n            &#10003;\n          </span> : <span className={classes.unchecked} role=\"img\" aria-label=\"unchecked\">\n            &#10007;\n          </span>;\n  const bodyText = useText(content);\n  const propContent = isDev ? `{{ ${propertyName} }}` : <>{!isBooleanProperty ? <Property id={property} /> : checkboxStatus}</>;\n  let columnText = propertyName ? propContent : contentPlaceholder;\n\n  if (type === 'ME_PROPERTY') {\n    columnText = isDev ? `{{ ${propertyName} }}` : useText([property]);\n  }\n\n  if (bodyText) {\n    columnText = bodyText;\n  }\n\n  const header = useText(headerText);\n  let columnHeaderText = propertyLabel || contentPlaceholder;\n\n  if (header) {\n    columnHeaderText = header;\n  }\n\n  const isSortable = propertyName && sortable;\n\n  const createSortHandler = prop => {\n    const sortOrder = order === 'asc' ? 'desc' : 'asc';\n    handleSort(prop, sortOrder);\n  };\n\n  const isFilterSelected = fields => {\n    if (!fields || fields.length !== propertyPath.length) return false;\n\n    for (let index = 0; index < fields.length; index += 1) {\n      if (fields[index] !== propertyPath[index]) return false;\n    }\n\n    return true;\n  };\n\n  const Content = children.length > 0 ? children : showTextToolTip ? <Tooltip title={columnText} enterDelay={1500} leaveDelay={200}>\n          <span className={classes.content}>{columnText}</span>\n        </Tooltip> : <span className={classes.content}>{columnText}</span>;\n  const Header = isSortable ? <TableSortLabel classes={{\n    root: classes.columnSort\n  }} active={isFilterSelected(field)} direction={isFilterSelected(field) && order ? order : 'asc'} onClick={() => createSortHandler(propertyPath)}>\n        <span className={classes.columnHeader}>{columnHeaderText}</span>\n      </TableSortLabel> : <span className={classes.columnHeader}>{columnHeaderText}</span>;\n  const [visible, setVisible] = useState(false);\n  useEffect(() => {\n    setVisible(options.visible);\n  }, []);\n  B.defineFunction('Hide', () => setVisible(false));\n  B.defineFunction('Show', () => setVisible(true));\n  B.defineFunction('Show/Hide', () => setVisible(s => !s));\n\n  if (isDev) {\n    return <div className={[classes.tableColumn, !headerOnly ? classes.tableColumnBody : '', !headerOnly ? 'MuiTableCell-root' : ''].join(' ')}>\n          {headerOnly ? <TableCell align={horizontalAlignment} component=\"div\">\n              {Header}\n            </TableCell> : Content}\n        </div>;\n  }\n\n  return visible ? <TableCell classes={{\n    root: classes.root\n  }} align={horizontalAlignment} // onClick={() =>\n  //   rowClick && myEndpoint && handleRowClick(myEndpoint, context)\n  // }\n  >\n        {headerOnly ? Header : Content}\n      </TableCell> : <></>;\n})()","styles":"B => theme => {\n  const {\n    env,\n    mediaMinWidth,\n    Styling\n  } = B;\n  const style = new Styling(theme);\n  const isDev = env === 'dev';\n  return {\n    tableColumn: {\n      display: 'table-cell',\n      verticalAlign: 'middle',\n      width: ({\n        options: {\n          width\n        }\n      }) => width || 'auto',\n      '& > div': {\n        display: 'block'\n      }\n    },\n    tableColumnBody: {\n      textAlign: ({\n        options: {\n          horizontalAlignment\n        }\n      }) => [horizontalAlignment, '!important'],\n      backgroundColor: ({\n        options: {\n          background\n        }\n      }) => [style.getColor(background), '!important'],\n      borderColor: ({\n        options: {\n          borderColor\n        }\n      }) => [style.getColor(borderColor), '!important']\n    },\n    root: {\n      display: isDev && ['block', '!important'],\n      width: ({\n        options: {\n          width\n        }\n      }) => width || 'auto',\n      backgroundColor: ({\n        options: {\n          background\n        }\n      }) => [style.getColor(background), '!important'],\n      borderColor: ({\n        options: {\n          borderColor\n        }\n      }) => [style.getColor(borderColor), '!important']\n    },\n    columnHeader: {\n      color: ({\n        options: {\n          type\n        }\n      }) => style.getFontColor(type),\n      fontFamily: ({\n        options: {\n          type\n        }\n      }) => style.getFontFamily(type),\n      fontSize: ({\n        options: {\n          type\n        }\n      }) => style.getFontSize(type),\n      fontWeight: ({\n        options: {\n          type\n        }\n      }) => style.getFontWeight(type),\n      textTransform: ({\n        options: {\n          type\n        }\n      }) => style.getTextTransform(type),\n      letterSpacing: ({\n        options: {\n          type\n        }\n      }) => style.getLetterSpacing(type),\n      lineHeight: '1.2',\n      [`@media ${mediaMinWidth(600)}`]: {\n        fontSize: ({\n          options: {\n            type\n          }\n        }) => style.getFontSize(type, 'Portrait')\n      },\n      [`@media ${mediaMinWidth(960)}`]: {\n        fontSize: ({\n          options: {\n            type\n          }\n        }) => style.getFontSize(type, 'Landscape')\n      },\n      [`@media ${mediaMinWidth(1280)}`]: {\n        fontSize: ({\n          options: {\n            type\n          }\n        }) => style.getFontSize(type, 'Desktop')\n      }\n    },\n    content: {\n      color: ({\n        options: {\n          bodyType\n        }\n      }) => style.getFontColor(bodyType),\n      fontFamily: ({\n        options: {\n          bodyType\n        }\n      }) => style.getFontFamily(bodyType),\n      fontSize: ({\n        options: {\n          bodyType\n        }\n      }) => style.getFontSize(bodyType),\n      fontWeight: ({\n        options: {\n          bodyType\n        }\n      }) => style.getFontWeight(bodyType),\n      textTransform: ({\n        options: {\n          bodyType\n        }\n      }) => style.getTextTransform(bodyType),\n      letterSpacing: ({\n        options: {\n          bodyType\n        }\n      }) => style.getLetterSpacing(bodyType),\n      lineHeight: '1.2',\n      [`@media ${mediaMinWidth(600)}`]: {\n        fontSize: ({\n          options: {\n            bodyType\n          }\n        }) => style.getFontSize(bodyType, 'Portrait')\n      },\n      [`@media ${mediaMinWidth(960)}`]: {\n        fontSize: ({\n          options: {\n            bodyType\n          }\n        }) => style.getFontSize(bodyType, 'Landscape')\n      },\n      [`@media ${mediaMinWidth(1280)}`]: {\n        fontSize: ({\n          options: {\n            bodyType\n          }\n        }) => style.getFontSize(bodyType, 'Desktop')\n      }\n    },\n    columnSort: {\n      pointerEvents: isDev && 'none',\n      '& .MuiSvgIcon-root': {\n        opacity: isDev && 0.5\n      }\n    },\n    checked: {\n      color: style.getColor('Success')\n    },\n    unchecked: {\n      color: style.getColor('Danger')\n    }\n  };\n}","functions":["Hide","Show","Show/Hide"],"triggers":[],"interactions":{},"componentHash":"60866576b31b266c05033da740b2a89f2bfcdc4d6f79f9149443090d382f2df5"},{"name":"getLocalStorage","type":"CONTENT_COMPONENT","icon":"TitleIcon","orientation":"HORIZONTAL","allowedTypes":["BODY_COMPONENT","CONTAINER_COMPONENT","CONTENT_COMPONENT"],"jsx":"(() => {\n  const {\n    env\n  } = B;\n  const isDev = env === 'dev';\n  const Tag = {\n    Title1: 'h1',\n    Title2: 'h2',\n    Title3: 'h3',\n    Title4: 'h4',\n    Title5: 'h5',\n    Title6: 'h6',\n    Body1: 'p',\n    Body2: 'p'\n  }[options.type || 'Title1'];\n  B.defineFunction('GetStoredObject', keys => {\n    // eslint-disable-next-line array-callback-return\n    keys.map(key => {\n      const storedObject = JSON.parse(localStorage.getItem(key));\n\n      if (storedObject) {\n        B.triggerEvent('GotStoredObject', storedObject);\n      }\n    });\n  });\n  return isDev ? <Tag className={classes.root}>\n        <p>getStorage component</p>\n      </Tag> : <></>;\n})()","styles":"B => t => {\n  const style = new B.Styling(t);\n  return {\n    root: {\n      boxSizing: 'border-box',\n      position: 'relative',\n      width: '100%',\n      margin: 0,\n      paddingTop: ({\n        options: {\n          padding\n        }\n      }) => style.getSpacing(padding[0], 'Desktop'),\n      paddingRight: ({\n        options: {\n          padding\n        }\n      }) => style.getSpacing(padding[1], 'Desktop'),\n      paddingBottom: ({\n        options: {\n          padding\n        }\n      }) => style.getSpacing(padding[2], 'Desktop'),\n      paddingLeft: ({\n        options: {\n          padding\n        }\n      }) => style.getSpacing(padding[3], 'Desktop'),\n      fontFamily: ({\n        options: {\n          type\n        }\n      }) => style.getFontFamily(type),\n      fontSize: ({\n        options: {\n          type\n        }\n      }) => style.getFontSize(type),\n      textTransform: ({\n        options: {\n          type\n        }\n      }) => style.getTextTransform(type),\n      fontWeight: ({\n        options: {\n          type\n        }\n      }) => style.getFontWeight(type),\n      letterSpacing: ({\n        options: {\n          type\n        }\n      }) => style.getLetterSpacing(type),\n      textAlign: ({\n        options: {\n          align\n        }\n      }) => align,\n      color: ({\n        options: {\n          color\n        }\n      }) => style.getColor(color)\n    }\n  };\n}","functions":["GetStoredObject"],"triggers":["GotStoredObject"],"interactions":{},"componentHash":"14f97e6c4814d4873b4ccd051375d68a710397179922f528b4097078678f6d2a"},{"name":"HiddenInput","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    disabled,\n    customModelAttribute: customModelAttributeObj,\n    nameAttribute\n  } = options;\n  const {\n    useText,\n    env,\n    getCustomModelAttribute\n  } = B;\n  const isDev = env === 'dev';\n  const {\n    id: customModelAttributeId,\n    value: defaultValue = ['']\n  } = customModelAttributeObj;\n  const customModelAttribute = getCustomModelAttribute(customModelAttributeId);\n  const [currentValue, setCurrentValue] = useState(useText(defaultValue));\n  const {\n    name: customModelAttributeName,\n    validations: {\n      required\n    } = {}\n  } = customModelAttribute || {};\n  const nameAttributeValue = useText(nameAttribute);\n  const [firstLoad, setFirstLoad] = useState(true);\n  useEffect(() => {\n    if (isDev) {\n      setCurrentValue(useText(defaultValue));\n    }\n  }, [isDev, defaultValue]);\n  useEffect(() => {\n    if (!firstLoad) {\n      B.triggerEvent('SubmitForm');\n    } else {\n      setFirstLoad(false);\n    }\n  }, [currentValue]);\n  B.defineFunction('SetHiddenInput', data => {\n    // console.log(data);\n    setCurrentValue(data);\n  });\n  const InputCmp = <input className={isDev && classes.pristine} type={isDev ? 'text' : 'hidden'} name={nameAttributeValue || customModelAttributeName} value={isDev ? currentValue || '{{ hidden input }}' : currentValue} required={required} disabled={disabled} />;\n  return isDev ? <div className={classes.root}>{InputCmp}</div> : InputCmp;\n})()","styles":"() => () => ({\n  root: {\n    '& > *': {\n      pointerEvents: 'none'\n    }\n  },\n  pristine: {\n    borderWidth: '0.0625rem',\n    borderColor: '#AFB5C8',\n    borderStyle: 'dashed',\n    backgroundColor: '#F0F1F5',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    minHeight: '2rem',\n    width: '100%',\n    fontSize: '0.75rem',\n    color: '#262A3A',\n    textTransform: 'uppercase',\n    boxSizing: 'border-box',\n    textAlign: 'center'\n  }\n})","functions":["SetHiddenInput"],"triggers":["SubmitForm"],"interactions":{},"componentHash":"663794c3530f9b556534aaeb9ae70c435a9186cd2e9f158945dc292a68e900d2"},{"name":"queryHandler","type":"CONTENT_COMPONENT","icon":"TitleIcon","orientation":"HORIZONTAL","allowedTypes":["BODY_COMPONENT","CONTAINER_COMPONENT","CONTENT_COMPONENT"],"jsx":"(() => {\n  const {\n    key,\n    valueTrue\n  } = options;\n  const {\n    env,\n    useText\n  } = B;\n  const isDev = env === 'dev';\n  const Tag = {\n    Title1: 'h1',\n    Title2: 'h2',\n    Title3: 'h3',\n    Title4: 'h4',\n    Title5: 'h5',\n    Title6: 'h6',\n    Body1: 'p',\n    Body2: 'p'\n  }[options.type || 'Title1'];\n  const keyText = useText(key);\n  const valueTrueText = useText(valueTrue);\n  const [isChecked, setIsChecked] = useState(false);\n\n  function getQueryString() {\n    const queryStringKeyValues = window.location.search.replace('?', '').split('&');\n    const qsJsonObject = {};\n\n    if (queryStringKeyValues !== '[\"\"]') {\n      // eslint-disable-next-line array-callback-return\n      queryStringKeyValues.map(queryStringKeyValue => {\n        let split = [];\n        split = queryStringKeyValue.split('='); // eslint-disable-next-line prefer-destructuring\n\n        qsJsonObject[split[0]] = split[1];\n      });\n    }\n\n    return qsJsonObject;\n  }\n\n  const queryString = getQueryString();\n  const queryValue = queryString[keyText];\n\n  if (queryValue === valueTrueText) {\n    B.triggerEvent('queryTrue');\n  } else {\n    B.triggerEvent('queryFalse');\n  }\n\n  B.defineFunction('dataTableReload', () => {\n    // eslint-disable-next-line array-callback-return\n    if (!isChecked && queryValue === valueTrueText) {\n      setIsChecked(true);\n      B.triggerEvent('dataTableReload');\n    }\n  });\n  return isDev ? <Tag className={classes.root}>\n        <p>queryHandler component</p>\n      </Tag> : <></>;\n})()","styles":"B => t => {\n  const style = new B.Styling(t);\n  return {\n    root: {\n      boxSizing: 'border-box',\n      position: 'relative',\n      width: '100%',\n      margin: 0,\n      paddingTop: ({\n        options: {\n          padding\n        }\n      }) => style.getSpacing(padding[0], 'Desktop'),\n      paddingRight: ({\n        options: {\n          padding\n        }\n      }) => style.getSpacing(padding[1], 'Desktop'),\n      paddingBottom: ({\n        options: {\n          padding\n        }\n      }) => style.getSpacing(padding[2], 'Desktop'),\n      paddingLeft: ({\n        options: {\n          padding\n        }\n      }) => style.getSpacing(padding[3], 'Desktop'),\n      fontFamily: ({\n        options: {\n          type\n        }\n      }) => style.getFontFamily(type),\n      fontSize: ({\n        options: {\n          type\n        }\n      }) => style.getFontSize(type),\n      textTransform: ({\n        options: {\n          type\n        }\n      }) => style.getTextTransform(type),\n      fontWeight: ({\n        options: {\n          type\n        }\n      }) => style.getFontWeight(type),\n      letterSpacing: ({\n        options: {\n          type\n        }\n      }) => style.getLetterSpacing(type),\n      textAlign: ({\n        options: {\n          align\n        }\n      }) => align,\n      color: ({\n        options: {\n          color\n        }\n      }) => style.getColor(color)\n    }\n  };\n}","functions":["dataTableReload"],"triggers":["queryTrue","queryFalse","dataTableReload"],"interactions":{},"componentHash":"bfe6175bb6277bbe401eb5e24f696f0cbfd9cc85e26d358db1b0b760dfddecdd"},{"name":"Select Filter","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    disabled,\n    variant,\n    size,\n    fullWidth,\n    margin,\n    helperText,\n    selectOptions = '',\n    model,\n    filter,\n    optionType,\n    labelProperty: labelProp,\n    valueProperty: valueProp,\n    valuePropertyTable: valuePropTable,\n    showError,\n    customModelAttribute: customModelAttributeObj,\n    property,\n    validationValueMissing,\n    nameAttribute,\n    order,\n    orderBy,\n    blanco,\n    interactionId,\n    onPremiseV9\n  } = options;\n  const {\n    env,\n    getCustomModelAttribute,\n    getProperty,\n    useAllQuery,\n    useText\n  } = B;\n  const {\n    TextField,\n    MenuItem\n  } = window.MaterialUI.Core;\n  const displayError = showError === 'built-in';\n  const isDev = env === 'dev';\n  const [errorState, setErrorState] = useState(false);\n  const [afterFirstInvalidation, setAfterFirstInvalidation] = useState(false);\n  const [helper, setHelper] = useState(useText(helperText));\n  const mounted = useRef(false);\n  const blancoText = useText(blanco);\n  const {\n    kind,\n    values = []\n  } = getProperty(property) || {};\n  const {\n    id: customModelAttributeId,\n    label = [],\n    value: defaultValue = []\n  } = customModelAttributeObj;\n  const onPremisePropTable = onPremiseV9 ? valuePropTable : valuePropTable.id;\n  const [currentValue, setCurrentValue] = useState(useText(defaultValue));\n  const labelText = useText(label);\n  const nameAttributeValue = useText(nameAttribute);\n  const customModelAttribute = getCustomModelAttribute(customModelAttributeId);\n  const {\n    name: customModelAttributeName,\n    validations: {\n      required\n    } = {}\n  } = customModelAttribute || {};\n  const value = currentValue;\n  const {\n    name: labelName\n  } = getProperty(labelProp) || {};\n  const {\n    name: propName\n  } = getProperty(valueProp) || {};\n  const orderByArray = [orderBy].flat();\n  const sort = !isDev && orderBy ? orderByArray.reduceRight((acc, orderByProperty, index) => {\n    const prop = getProperty(orderByProperty);\n    return index === orderByArray.length - 1 ? {\n      [prop.name]: order.toUpperCase()\n    } : {\n      [prop.name]: acc\n    };\n  }, {}) : {};\n  const {\n    loading,\n    error,\n    data,\n    refetch\n  } = model && useAllQuery(model, {\n    filter,\n    skip: 0,\n    take: 50,\n    variables: { ...(orderBy ? {\n        sort: {\n          relation: sort\n        }\n      } : {})\n    },\n\n    onCompleted(res) {\n      const hasResult = res && res.results && res.results.length > 0;\n\n      if (hasResult) {\n        B.triggerEvent('onSuccess', res.results);\n      } else {\n        B.triggerEvent('onNoResults');\n      }\n    },\n\n    onError(resp) {\n      if (!displayError) {\n        B.triggerEvent('onError', resp);\n      }\n    }\n\n  });\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n  useEffect(() => {\n    B.triggerEvent('onChange', currentValue);\n  });\n  useEffect(() => {\n    if (mounted.current && loading) {\n      B.triggerEvent('onLoad', loading);\n    }\n  }, [loading]);\n  const {\n    results\n  } = data || {};\n  B.defineFunction('Refetch', () => refetch());\n\n  const handleValidation = () => {\n    const hasError = required && !value;\n    setErrorState(hasError);\n    const message = useText(hasError ? validationValueMissing : helperText);\n    setHelper(message);\n  };\n\n  const handleChange = event => {\n    const {\n      target: {\n        value: eventValue\n      }\n    } = event;\n\n    if (afterFirstInvalidation) {\n      handleValidation();\n    }\n\n    setCurrentValue(eventValue);\n    const filterObject = {\n      id: onPremisePropTable,\n      operator: 'eq'\n    };\n    const filterArray = [filterObject, eventValue, interactionId];\n    B.triggerEvent('SetFilter', filterArray);\n    const storage = {\n      data: filterArray,\n      key: interactionId\n    };\n    B.triggerEvent('SetLocalStorage', storage);\n  };\n\n  const validationHandler = () => {\n    const hasError = required && !value;\n    setAfterFirstInvalidation(hasError);\n    handleValidation();\n  };\n\n  useEffect(() => {\n    if (isDev) {\n      setCurrentValue(useText(defaultValue));\n    }\n  }, [isDev, defaultValue]);\n\n  const renderOptions = () => {\n    if (kind === 'list' || kind === 'LIST') {\n      return values.map(({\n        value: v\n      }) => <MenuItem key={v} value={v}>\n            {v}\n          </MenuItem>);\n    }\n\n    if (optionType === 'static') {\n      return selectOptions.split('\\n').map(option => <MenuItem key={option} value={option}>\n            {option}\n          </MenuItem>);\n    }\n\n    if (loading) return <span>Loading...</span>;\n    if (error && displayError) return <span>{error.message}</span>;\n    return (results || []).map(item => propName && labelName && <MenuItem key={item.id} value={item[propName]}>\n              {item[labelName]}\n            </MenuItem>);\n  };\n\n  B.defineFunction('GetStoredObjectTrigger', () => {\n    B.triggerEvent('GetStoredObject', [interactionId]);\n  });\n  B.defineFunction('GotStoredObject', storedFilterArray => {\n    if (storedFilterArray) {\n      setCurrentValue(storedFilterArray[1]);\n    }\n  });\n  const SelectCmp = <>\n        <TextField select defaultValue={value} value={value} size={size} classes={{\n      root: classes.formControl\n    }} variant={variant} fullWidth={fullWidth} onChange={handleChange} onBlur={validationHandler} inputProps={{\n      name: nameAttributeValue || customModelAttributeName,\n      tabIndex: isDev ? -1 : 0\n    }} required={required} disabled={disabled} label={labelText} error={errorState} margin={margin} helperText={helper}>\n          {blancoText && <MenuItem value=\"\">{blancoText}</MenuItem>}\n          {renderOptions()}\n        </TextField>\n        <input className={classes.validationInput} onInvalid={validationHandler} type=\"text\" tabIndex=\"-1\" required={required} value={value} />\n      </>;\n  return isDev ? <div className={classes.root}>{SelectCmp}</div> : SelectCmp;\n})()","styles":"B => t => {\n  const {\n    Styling\n  } = B;\n  const style = new Styling(t);\n  return {\n    root: {\n      display: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth ? 'block' : 'inline-block',\n      '& > *': {\n        pointerEvents: 'none'\n      }\n    },\n    validationInput: {\n      height: 0,\n      width: 0,\n      fontSize: 0,\n      padding: 0,\n      border: 'none',\n      pointerEvents: 'none'\n    },\n    formControl: {\n      '& > label': {\n        color: ({\n          options: {\n            labelColor\n          }\n        }) => [style.getColor(labelColor), '!important'],\n        zIndex: ({\n          options: {\n            variant\n          }\n        }) => variant === 'standard' ? 1 : null,\n        '&.Mui-focused': {\n          color: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        },\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& > p': {\n        color: ({\n          options: {\n            helperColor\n          }\n        }) => [style.getColor(helperColor), '!important'],\n        '&.Mui-error': {\n          color: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important'],\n        backgroundColor: ({\n          options: {\n            backgroundColor\n          }\n        }) => [style.getColor(backgroundColor), '!important'],\n        '&:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused, &.Mui-focused:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderFocusColor\n              }\n            }) => [style.getColor(borderFocusColor), '!important']\n          }\n        },\n        '& fieldset': {\n          top: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? 0 : null\n        },\n        '& legend': {\n          display: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? ['none', '!important'] : null\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& .MuiIconButton-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important']\n      },\n      '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n        borderColor: ({\n          options: {\n            borderColor\n          }\n        }) => [style.getColor(borderColor), '!important']\n      },\n      '& .MuiInput-underline, & .MuiFilledInput-underline': {\n        '&::before, &::after': {\n          borderColor: ({\n            options: {\n              borderColor\n            }\n          }) => [style.getColor(borderColor), '!important']\n        },\n        '&:hover': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n          borderColor: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root.Mui-error, & .MuiInputBase-root.Mui-error:hover, & .MuiInputBase-root.Mui-error.Mui-focused, & .MuiInputBase-root.Mui-error.Mui-focused:hover': {\n        '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n          borderColor: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.MuiInput-underline, &.MuiFilledInput-underline': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          },\n          '&:hover': {\n            '&::before, &::after': {\n              borderColor: ({\n                options: {\n                  errorColor\n                }\n              }) => [style.getColor(errorColor), '!important']\n            }\n          },\n          '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          }\n        }\n      }\n    }\n  };\n}","functions":["Refetch","GetStoredObjectTrigger","GotStoredObject"],"triggers":["onSuccess","onNoResults","onError","onChange","onLoad","SetFilter","SetLocalStorage","GetStoredObject"],"interactions":{},"componentHash":"683a5cde6fbaa6105ca29a3fedaf1fd7c6dcbc8c44870042896b1f94d028cf8a"},{"name":"setLocalStorage","type":"CONTENT_COMPONENT","icon":"TitleIcon","orientation":"HORIZONTAL","allowedTypes":["BODY_COMPONENT","CONTAINER_COMPONENT","CONTENT_COMPONENT"],"jsx":"(() => {\n  const {\n    onPremiseV9\n  } = options;\n  const {\n    env\n  } = B;\n  const isDev = env === 'dev';\n  const Tag = {\n    Title1: 'h1',\n    Title2: 'h2',\n    Title3: 'h3',\n    Title4: 'h4',\n    Title5: 'h5',\n    Title6: 'h6',\n    Body1: 'p',\n    Body2: 'p'\n  }[options.type || 'Title1'];\n  B.defineFunction('SetLocalStorage', data => {\n    localStorage.setItem(data.key, JSON.stringify(data.data));\n  });\n  B.defineFunction('SetLogging', data => {\n    // console.log(data);\n    const ids = data.storageResults.data.results.map(a => a.id);\n    const filterKeys = Object.keys(data.storageFilters.data);\n    const total = data.storageResults.data.totalCount; // console.log(total);\n    // console.log(data.storageFilters.data);\n\n    const filters = filterKeys.map(a => `[${a},${data.storageFilters.data[a].value}]`); // console.log(filters);\n    // const total = data.storageFilters.data.results.map(a => a.id);\n\n    B.triggerEvent('SetInputIds', ids);\n    B.triggerEvent('SetInputFilters', filters);\n    B.triggerEvent('SetInputTotal', total);\n  });\n  B.defineFunction('ClearLocalStorage', () => {\n    if (onPremiseV9) {\n      const token = localStorage.getItem('TOKEN');\n      const refreshToken = localStorage.getItem('REFRESH_TOKEN');\n      localStorage.clear();\n      localStorage.setItem('TOKEN', token);\n      localStorage.setItem('REFRESH_TOKEN', refreshToken);\n    } else {\n      localStorage.clear();\n    }\n  });\n  return isDev ? <Tag className={classes.root}>\n        <p>setStorage component</p>\n      </Tag> : <></>;\n})()","styles":"B => t => {\n  const style = new B.Styling(t);\n  return {\n    root: {\n      boxSizing: 'border-box',\n      position: 'relative',\n      width: '100%',\n      margin: 0,\n      paddingTop: ({\n        options: {\n          padding\n        }\n      }) => style.getSpacing(padding[0], 'Desktop'),\n      paddingRight: ({\n        options: {\n          padding\n        }\n      }) => style.getSpacing(padding[1], 'Desktop'),\n      paddingBottom: ({\n        options: {\n          padding\n        }\n      }) => style.getSpacing(padding[2], 'Desktop'),\n      paddingLeft: ({\n        options: {\n          padding\n        }\n      }) => style.getSpacing(padding[3], 'Desktop'),\n      fontFamily: ({\n        options: {\n          type\n        }\n      }) => style.getFontFamily(type),\n      fontSize: ({\n        options: {\n          type\n        }\n      }) => style.getFontSize(type),\n      textTransform: ({\n        options: {\n          type\n        }\n      }) => style.getTextTransform(type),\n      fontWeight: ({\n        options: {\n          type\n        }\n      }) => style.getFontWeight(type),\n      letterSpacing: ({\n        options: {\n          type\n        }\n      }) => style.getLetterSpacing(type),\n      textAlign: ({\n        options: {\n          align\n        }\n      }) => align,\n      color: ({\n        options: {\n          color\n        }\n      }) => style.getColor(color)\n    }\n  };\n}","functions":["SetLocalStorage","SetLogging","ClearLocalStorage"],"triggers":["SetInputIds","SetInputFilters","SetInputTotal"],"interactions":{},"componentHash":"111932eeba55704868aac6d13e7794b77b3bc2b0c873968ce846170591f7c525"},{"name":"ANDOR TextField Filtering","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    disabled,\n    error,\n    multiline,\n    rows,\n    placeholder,\n    variant,\n    type,\n    size,\n    fullWidth,\n    margin,\n    helperText,\n    adornment,\n    adornmentIcon,\n    adornmentPosition,\n    pattern,\n    minlength,\n    maxlength,\n    validationTypeMismatch,\n    validationPatternMismatch,\n    validationValueMissing,\n    validationTooLong,\n    validationTooShort,\n    hideLabel,\n    customModelAttribute: customModelAttributeObj,\n    nameAttribute,\n    valuePropertyTable: valuePropTable,\n    interactionId\n  } = options;\n  const {\n    FormControl,\n    Input,\n    OutlinedInput,\n    FilledInput,\n    InputLabel,\n    FormHelperText,\n    InputAdornment,\n    IconButton\n  } = window.MaterialUI.Core;\n  const {\n    Icons\n  } = window.MaterialUI;\n  const {\n    env,\n    getCustomModelAttribute,\n    useText\n  } = B;\n  const isDev = env === 'dev';\n  const isNumberType = type === 'number';\n  const isPasswordType = type === 'password';\n  const [isDisabled, setIsDisabled] = useState(disabled);\n  const [showPassword, togglePassword] = useState(false);\n  const [errorState, setErrorState] = useState(error);\n  const [afterFirstInvalidation, setAfterFirstInvalidation] = useState(false);\n  const [helper, setHelper] = useState(useText(helperText));\n  const {\n    id: customModelAttributeId,\n    label = [],\n    value: defaultValue = []\n  } = customModelAttributeObj;\n  const [currentValue, setCurrentValue] = useState(useText(defaultValue));\n  const labelText = useText(label);\n  const customModelAttribute = getCustomModelAttribute(customModelAttributeId);\n  const onPremisePropTable = valuePropTable.id;\n  const {\n    name: customModelAttributeName,\n    validations: {\n      required\n    } = {}\n  } = customModelAttribute || {};\n  const nameAttributeValue = useText(nameAttribute);\n  const validPattern = pattern || null;\n  const validMinlength = minlength || null;\n  const validMaxlength = maxlength || null;\n\n  const validationMessage = validityObject => {\n    if (validityObject.customError && validationPatternMismatch) {\n      return useText(validationPatternMismatch);\n    }\n\n    if (validityObject.valid) {\n      return '';\n    }\n\n    if (validityObject.typeMismatch && validationTypeMismatch) {\n      return useText(validationTypeMismatch);\n    }\n\n    if (validityObject.patternMismatch && validationPatternMismatch) {\n      return useText(validationPatternMismatch);\n    }\n\n    if (validityObject.valueMissing && validationValueMissing) {\n      return useText(validationValueMissing);\n    }\n\n    if (validityObject.tooLong && validationTooLong) {\n      return useText(validationTooLong);\n    }\n\n    if (validityObject.tooShort && validationTooShort) {\n      return useText(validationTooShort);\n    }\n\n    return '';\n  };\n\n  const placeholderText = useText(placeholder);\n\n  const handleValidation = validation => {\n    setErrorState(!validation.valid);\n    const message = validationMessage(validation) || useText(helperText);\n    setHelper(message);\n  };\n\n  const onKeyDown = event => {\n    if (isNumberType && (event.key === '.' || event.key === ',')) {\n      event.preventDefault();\n    }\n  };\n\n  const customPatternValidation = target => {\n    const {\n      value: eventValue,\n      validity\n    } = target;\n\n    if (!pattern) {\n      return validity;\n    }\n\n    const patternRegex = RegExp(`^${pattern}$`);\n    const isValid = patternRegex.test(eventValue);\n    target.setCustomValidity(isValid ? '' : 'Invalid field.');\n    return { ...validity,\n      valid: isValid,\n      patternMismatch: !isValid\n    };\n  };\n\n  const changeHandler = event => {\n    const {\n      target\n    } = event;\n    let {\n      validity: validation\n    } = target;\n    const {\n      value: eventValue\n    } = target;\n    const filterObject = {\n      id: onPremisePropTable,\n      operator: 'regex'\n    };\n    let eventVariable = eventValue;\n\n    if (isNumberType || multiline) {\n      validation = customPatternValidation(target);\n    }\n\n    const numberValue = isNumberType && eventValue && parseInt(eventValue, 10);\n\n    if (afterFirstInvalidation) {\n      handleValidation(validation);\n    }\n\n    setCurrentValue(isNumberType ? numberValue : eventValue); // Now make this able to process the deeper arrays, then test whether the GraphQL is on board or whether the _and operators need to be added,\n    // lorem AND ipsum OR kees\n\n    const splitIntoArray = (keyword, value) => value.split(` ${keyword} `);\n\n    if (eventVariable.includes(' AND ')) {\n      const temp = splitIntoArray('AND', eventVariable);\n      eventVariable = temp;\n      temp.forEach((value, index) => {\n        if (value.includes(' OR ')) {\n          const temp2 = splitIntoArray('OR', value);\n          const temp3 = {\n            and: temp2\n          };\n          eventVariable[index] = temp3;\n        } else {\n          const temp2 = {\n            and: value\n          };\n          eventVariable[index] = temp2;\n        }\n      });\n    } else if (eventVariable.includes(' OR ')) {\n      eventVariable = splitIntoArray('OR', eventVariable);\n    }\n\n    console.log(eventVariable);\n    const filterArray = [filterObject, eventVariable, interactionId];\n    B.triggerEvent('SetFilter', filterArray);\n  };\n\n  const blurHandler = event => {\n    const {\n      target\n    } = event;\n    let {\n      validity: validation\n    } = target;\n\n    if (isNumberType || multiline) {\n      validation = customPatternValidation(target);\n    }\n\n    setAfterFirstInvalidation(!validation.valid);\n    handleValidation(validation);\n  };\n\n  const invalidHandler = event => {\n    event.preventDefault();\n    const {\n      target: {\n        validity,\n        validity: {\n          valid: isValid\n        }\n      }\n    } = event;\n    setAfterFirstInvalidation(!isValid);\n    handleValidation(validity);\n  };\n\n  B.defineFunction('Clear', () => setCurrentValue(''));\n  B.defineFunction('Enable', () => setIsDisabled(false));\n  B.defineFunction('Disable', () => setIsDisabled(true));\n\n  const handleClickShowPassword = () => {\n    togglePassword(!showPassword);\n  };\n\n  const handleMouseDownPassword = event => {\n    event.preventDefault();\n  };\n\n  let InputCmp = Input;\n\n  if (variant === 'outlined') {\n    InputCmp = OutlinedInput;\n  } else if (variant === 'filled') {\n    InputCmp = FilledInput;\n  }\n\n  const passwordIcon = showPassword ? 'Visibility' : 'VisibilityOff';\n  const inputIcon = isPasswordType ? passwordIcon : adornmentIcon;\n  const hasIcon = inputIcon && inputIcon !== 'none';\n  const hasAdornment = isPasswordType ? adornment && hasIcon : adornment || hasIcon;\n  const IconCmp = hasIcon && React.createElement(Icons[inputIcon], {\n    fontSize: size\n  });\n  const iconButtonOptions = {\n    edge: adornmentPosition,\n    tabIndex: isDev && -1\n  };\n\n  if (isPasswordType) {\n    iconButtonOptions.ariaLabel = 'toggle password visibility';\n    iconButtonOptions.onClick = handleClickShowPassword;\n    iconButtonOptions.onMouseDown = handleMouseDownPassword;\n  }\n\n  useEffect(() => {\n    if (isDev) {\n      setCurrentValue(useText(defaultValue));\n      setHelper(useText(helperText));\n    }\n  }, [isDev, defaultValue, helperText]);\n  const TextFieldCmp = <FormControl classes={{\n    root: classes.formControl\n  }} variant={variant} size={size} fullWidth={fullWidth} required={required} disabled={isDisabled} margin={margin} error={errorState}>\n        {labelText && !hideLabel && <InputLabel classes={{\n      root: classes.label\n    }}>{labelText}</InputLabel>}\n        <InputCmp name={nameAttributeValue || customModelAttributeName} value={currentValue} type={isDev && type === 'number' || showPassword ? 'text' : type} multiline={multiline} rows={rows} label={labelText} placeholder={placeholderText} onKeyDown={onKeyDown} onChange={changeHandler} onBlur={blurHandler} onInvalid={invalidHandler} startAdornment={hasAdornment && adornmentPosition === 'start' && <InputAdornment position={adornmentPosition}>\n                {hasIcon ? <IconButton {...iconButtonOptions}>{IconCmp}</IconButton> : adornment}\n              </InputAdornment>} endAdornment={hasAdornment && adornmentPosition === 'end' && <InputAdornment position={adornmentPosition}>\n                {hasIcon ? <IconButton {...iconButtonOptions}>{IconCmp}</IconButton> : adornment}\n              </InputAdornment>} inputProps={{\n      pattern: validPattern,\n      minlength: validMinlength,\n      maxlength: validMaxlength,\n      tabIndex: isDev && -1\n    }} />\n        {helper && <FormHelperText classes={{\n      root: classes.helper\n    }}>\n            {helper}\n          </FormHelperText>}\n      </FormControl>;\n  return isDev ? <div className={classes.root}>{TextFieldCmp}</div> : TextFieldCmp;\n})()","styles":"B => t => {\n  const {\n    Styling\n  } = B;\n  const style = new Styling(t);\n  return {\n    root: {\n      display: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth ? 'block' : 'inline-block',\n      '& > *': {\n        pointerEvents: 'none'\n      }\n    },\n    label: {\n      color: ({\n        options: {\n          labelColor\n        }\n      }) => [style.getColor(labelColor), '!important'],\n      '&.Mui-focused': {\n        color: ({\n          options: {\n            borderFocusColor\n          }\n        }) => [style.getColor(borderFocusColor), '!important']\n      },\n      '&.Mui-error, &.Mui-error .Mui-error': {\n        color: ({\n          options: {\n            errorColor\n          }\n        }) => [style.getColor(errorColor), '!important']\n      },\n      '&.Mui-disabled': {\n        pointerEvents: 'none',\n        opacity: '0.7'\n      }\n    },\n    helper: {\n      color: ({\n        options: {\n          helperColor\n        }\n      }) => [style.getColor(helperColor), '!important'],\n      '&.Mui-error': {\n        color: ({\n          options: {\n            errorColor\n          }\n        }) => [style.getColor(errorColor), '!important']\n      }\n    },\n    formControl: {\n      '& .MuiInputBase-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important'],\n        backgroundColor: ({\n          options: {\n            backgroundColor,\n            variant\n          }\n        }) => variant !== 'standard' && [style.getColor(backgroundColor), '!important'],\n        '&:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused, &.Mui-focused:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderFocusColor\n              }\n            }) => [style.getColor(borderFocusColor), '!important']\n          }\n        },\n        '& fieldset': {\n          top: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? 0 : null\n        },\n        '& legend': {\n          display: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? ['none', '!important'] : null\n        },\n        '& input': {\n          '&::placeholder': {\n            color: ({\n              options: {\n                placeholderColor\n              }\n            }) => [style.getColor(placeholderColor), '!important']\n          }\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& .MuiIconButton-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important']\n      },\n      '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n        borderColor: ({\n          options: {\n            borderColor\n          }\n        }) => [style.getColor(borderColor), '!important']\n      },\n      '& .MuiInput-underline, & .MuiFilledInput-underline': {\n        '&::before, &::after': {\n          borderColor: ({\n            options: {\n              borderColor\n            }\n          }) => [style.getColor(borderColor), '!important']\n        },\n        '&:hover': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n          borderColor: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root.Mui-error, & .MuiInputBase-root.Mui-error:hover, & .MuiInputBase-root.Mui-error.Mui-focused, & .MuiInputBase-root.Mui-error.Mui-focused:hover': {\n        '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n          borderColor: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.MuiInput-underline, &.MuiFilledInput-underline': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          },\n          '&:hover': {\n            '&::before, &::after': {\n              borderColor: ({\n                options: {\n                  errorColor\n                }\n              }) => [style.getColor(errorColor), '!important']\n            }\n          },\n          '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          }\n        }\n      }\n    }\n  };\n}","functions":["Clear","Enable","Disable"],"triggers":["SetFilter"],"interactions":{},"componentHash":"8fb51b973f69b7ccaf78b9327e2d8407496af9d1bdc601c1c4a21237e4f78511"},{"name":"TextField Filtering","type":"CONTENT_COMPONENT","allowedTypes":[],"orientation":"HORIZONTAL","jsx":"(() => {\n  const {\n    disabled,\n    error,\n    multiline,\n    rows,\n    placeholder,\n    variant,\n    type,\n    size,\n    fullWidth,\n    margin,\n    helperText,\n    adornment,\n    adornmentIcon,\n    adornmentPosition,\n    pattern,\n    minlength,\n    maxlength,\n    validationTypeMismatch,\n    validationPatternMismatch,\n    validationValueMissing,\n    validationTooLong,\n    validationTooShort,\n    hideLabel,\n    customModelAttribute: customModelAttributeObj,\n    nameAttribute,\n    valuePropertyTable: valuePropTable,\n    interactionId\n  } = options;\n  const {\n    FormControl,\n    Input,\n    OutlinedInput,\n    FilledInput,\n    InputLabel,\n    FormHelperText,\n    InputAdornment,\n    IconButton\n  } = window.MaterialUI.Core;\n  const {\n    Icons\n  } = window.MaterialUI;\n  const {\n    env,\n    getCustomModelAttribute,\n    useText\n  } = B;\n  const isDev = env === 'dev';\n  const isNumberType = type === 'number';\n  const isPasswordType = type === 'password';\n  const [isDisabled, setIsDisabled] = useState(disabled);\n  const [showPassword, togglePassword] = useState(false);\n  const [errorState, setErrorState] = useState(error);\n  const [afterFirstInvalidation, setAfterFirstInvalidation] = useState(false);\n  const [helper, setHelper] = useState(useText(helperText));\n  const {\n    id: customModelAttributeId,\n    label = [],\n    value: defaultValue = []\n  } = customModelAttributeObj;\n  const [currentValue, setCurrentValue] = useState(useText(defaultValue));\n  const labelText = useText(label);\n  const customModelAttribute = getCustomModelAttribute(customModelAttributeId);\n  const onPremisePropTable = valuePropTable.id;\n  const {\n    name: customModelAttributeName,\n    validations: {\n      required\n    } = {}\n  } = customModelAttribute || {};\n  const nameAttributeValue = useText(nameAttribute);\n  const validPattern = pattern || null;\n  const validMinlength = minlength || null;\n  const validMaxlength = maxlength || null;\n\n  const validationMessage = validityObject => {\n    if (validityObject.customError && validationPatternMismatch) {\n      return useText(validationPatternMismatch);\n    }\n\n    if (validityObject.valid) {\n      return '';\n    }\n\n    if (validityObject.typeMismatch && validationTypeMismatch) {\n      return useText(validationTypeMismatch);\n    }\n\n    if (validityObject.patternMismatch && validationPatternMismatch) {\n      return useText(validationPatternMismatch);\n    }\n\n    if (validityObject.valueMissing && validationValueMissing) {\n      return useText(validationValueMissing);\n    }\n\n    if (validityObject.tooLong && validationTooLong) {\n      return useText(validationTooLong);\n    }\n\n    if (validityObject.tooShort && validationTooShort) {\n      return useText(validationTooShort);\n    }\n\n    return '';\n  };\n\n  const placeholderText = useText(placeholder);\n\n  const handleValidation = validation => {\n    setErrorState(!validation.valid);\n    const message = validationMessage(validation) || useText(helperText);\n    setHelper(message);\n  };\n\n  const onKeyDown = event => {\n    if (isNumberType && (event.key === '.' || event.key === ',')) {\n      event.preventDefault();\n    }\n  };\n\n  const customPatternValidation = target => {\n    const {\n      value: eventValue,\n      validity\n    } = target;\n\n    if (!pattern) {\n      return validity;\n    }\n\n    const patternRegex = RegExp(`^${pattern}$`);\n    const isValid = patternRegex.test(eventValue);\n    target.setCustomValidity(isValid ? '' : 'Invalid field.');\n    return { ...validity,\n      valid: isValid,\n      patternMismatch: !isValid\n    };\n  };\n\n  const changeHandler = event => {\n    const {\n      target\n    } = event;\n    let {\n      validity: validation\n    } = target;\n    const {\n      value: eventValue\n    } = target;\n\n    if (isNumberType || multiline) {\n      validation = customPatternValidation(target);\n    }\n\n    const numberValue = isNumberType && eventValue && parseInt(eventValue, 10);\n\n    if (afterFirstInvalidation) {\n      handleValidation(validation);\n    }\n\n    setCurrentValue(isNumberType ? numberValue : eventValue);\n    const filterObject = {\n      id: onPremisePropTable,\n      operator: 'regex'\n    };\n    const filterArray = [filterObject, eventValue, interactionId];\n    B.triggerEvent('SetFilter', filterArray);\n    const storage = {\n      data: filterArray,\n      key: interactionId\n    };\n    B.triggerEvent('SetLocalStorage', storage);\n  };\n\n  const blurHandler = event => {\n    const {\n      target\n    } = event;\n    let {\n      validity: validation\n    } = target;\n\n    if (isNumberType || multiline) {\n      validation = customPatternValidation(target);\n    }\n\n    setAfterFirstInvalidation(!validation.valid);\n    handleValidation(validation);\n  };\n\n  const invalidHandler = event => {\n    event.preventDefault();\n    const {\n      target: {\n        validity,\n        validity: {\n          valid: isValid\n        }\n      }\n    } = event;\n    setAfterFirstInvalidation(!isValid);\n    handleValidation(validity);\n  };\n\n  B.defineFunction('Clear', () => setCurrentValue(''));\n  B.defineFunction('Enable', () => setIsDisabled(false));\n  B.defineFunction('Disable', () => setIsDisabled(true));\n  B.defineFunction('GetStoredObjectTrigger', () => {\n    B.triggerEvent('GetStoredObject', [interactionId]);\n  });\n  B.defineFunction('GotStoredObject', storedFilterArray => {\n    if (storedFilterArray) {\n      setCurrentValue(storedFilterArray[1]);\n    }\n  });\n\n  const handleClickShowPassword = () => {\n    togglePassword(!showPassword);\n  };\n\n  const handleMouseDownPassword = event => {\n    event.preventDefault();\n  };\n\n  let InputCmp = Input;\n\n  if (variant === 'outlined') {\n    InputCmp = OutlinedInput;\n  } else if (variant === 'filled') {\n    InputCmp = FilledInput;\n  }\n\n  const passwordIcon = showPassword ? 'Visibility' : 'VisibilityOff';\n  const inputIcon = isPasswordType ? passwordIcon : adornmentIcon;\n  const hasIcon = inputIcon && inputIcon !== 'none';\n  const hasAdornment = isPasswordType ? adornment && hasIcon : adornment || hasIcon;\n  const IconCmp = hasIcon && React.createElement(Icons[inputIcon], {\n    fontSize: size\n  });\n  const iconButtonOptions = {\n    edge: adornmentPosition,\n    tabIndex: isDev && -1\n  };\n\n  if (isPasswordType) {\n    iconButtonOptions.ariaLabel = 'toggle password visibility';\n    iconButtonOptions.onClick = handleClickShowPassword;\n    iconButtonOptions.onMouseDown = handleMouseDownPassword;\n  }\n\n  useEffect(() => {\n    if (isDev) {\n      setCurrentValue(useText(defaultValue));\n      setHelper(useText(helperText));\n    }\n  }, [isDev, defaultValue, helperText]);\n  const TextFieldCmp = <FormControl classes={{\n    root: classes.formControl\n  }} variant={variant} size={size} fullWidth={fullWidth} required={required} disabled={isDisabled} margin={margin} error={errorState}>\n        {labelText && !hideLabel && <InputLabel classes={{\n      root: classes.label\n    }}>{labelText}</InputLabel>}\n        <InputCmp name={nameAttributeValue || customModelAttributeName} value={currentValue} type={isDev && type === 'number' || showPassword ? 'text' : type} multiline={multiline} rows={rows} label={labelText} placeholder={placeholderText} onKeyDown={onKeyDown} onChange={changeHandler} onBlur={blurHandler} onInvalid={invalidHandler} startAdornment={hasAdornment && adornmentPosition === 'start' && <InputAdornment position={adornmentPosition}>\n                {hasIcon ? <IconButton {...iconButtonOptions}>{IconCmp}</IconButton> : adornment}\n              </InputAdornment>} endAdornment={hasAdornment && adornmentPosition === 'end' && <InputAdornment position={adornmentPosition}>\n                {hasIcon ? <IconButton {...iconButtonOptions}>{IconCmp}</IconButton> : adornment}\n              </InputAdornment>} inputProps={{\n      pattern: validPattern,\n      minlength: validMinlength,\n      maxlength: validMaxlength,\n      tabIndex: isDev && -1\n    }} />\n        {helper && <FormHelperText classes={{\n      root: classes.helper\n    }}>\n            {helper}\n          </FormHelperText>}\n      </FormControl>;\n  return isDev ? <div className={classes.root}>{TextFieldCmp}</div> : TextFieldCmp;\n})()","styles":"B => t => {\n  const {\n    Styling\n  } = B;\n  const style = new Styling(t);\n  return {\n    root: {\n      display: ({\n        options: {\n          fullWidth\n        }\n      }) => fullWidth ? 'block' : 'inline-block',\n      '& > *': {\n        pointerEvents: 'none'\n      }\n    },\n    label: {\n      color: ({\n        options: {\n          labelColor\n        }\n      }) => [style.getColor(labelColor), '!important'],\n      '&.Mui-focused': {\n        color: ({\n          options: {\n            borderFocusColor\n          }\n        }) => [style.getColor(borderFocusColor), '!important']\n      },\n      '&.Mui-error, &.Mui-error .Mui-error': {\n        color: ({\n          options: {\n            errorColor\n          }\n        }) => [style.getColor(errorColor), '!important']\n      },\n      '&.Mui-disabled': {\n        pointerEvents: 'none',\n        opacity: '0.7'\n      }\n    },\n    helper: {\n      color: ({\n        options: {\n          helperColor\n        }\n      }) => [style.getColor(helperColor), '!important'],\n      '&.Mui-error': {\n        color: ({\n          options: {\n            errorColor\n          }\n        }) => [style.getColor(errorColor), '!important']\n      }\n    },\n    formControl: {\n      '& .MuiInputBase-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important'],\n        backgroundColor: ({\n          options: {\n            backgroundColor,\n            variant\n          }\n        }) => variant !== 'standard' && [style.getColor(backgroundColor), '!important'],\n        '&:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused, &.Mui-focused:hover': {\n          '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n            borderColor: ({\n              options: {\n                borderFocusColor\n              }\n            }) => [style.getColor(borderFocusColor), '!important']\n          }\n        },\n        '& fieldset': {\n          top: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? 0 : null\n        },\n        '& legend': {\n          display: ({\n            options: {\n              hideLabel\n            }\n          }) => hideLabel ? ['none', '!important'] : null\n        },\n        '& input': {\n          '&::placeholder': {\n            color: ({\n              options: {\n                placeholderColor\n              }\n            }) => [style.getColor(placeholderColor), '!important']\n          }\n        },\n        '&.Mui-disabled': {\n          pointerEvents: 'none',\n          opacity: '0.7'\n        }\n      },\n      '& .MuiIconButton-root': {\n        color: ({\n          options: {\n            textColor\n          }\n        }) => [style.getColor(textColor), '!important']\n      },\n      '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n        borderColor: ({\n          options: {\n            borderColor\n          }\n        }) => [style.getColor(borderColor), '!important']\n      },\n      '& .MuiInput-underline, & .MuiFilledInput-underline': {\n        '&::before, &::after': {\n          borderColor: ({\n            options: {\n              borderColor\n            }\n          }) => [style.getColor(borderColor), '!important']\n        },\n        '&:hover': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                borderHoverColor\n              }\n            }) => [style.getColor(borderHoverColor), '!important']\n          }\n        },\n        '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n          borderColor: ({\n            options: {\n              borderFocusColor\n            }\n          }) => [style.getColor(borderFocusColor), '!important']\n        }\n      },\n      '& .MuiInputBase-root.Mui-error, & .MuiInputBase-root.Mui-error:hover, & .MuiInputBase-root.Mui-error.Mui-focused, & .MuiInputBase-root.Mui-error.Mui-focused:hover': {\n        '& .MuiOutlinedInput-notchedOutline, & .MuiFilledInput-underline, & .MuiInput-underline': {\n          borderColor: ({\n            options: {\n              errorColor\n            }\n          }) => [style.getColor(errorColor), '!important']\n        },\n        '&.MuiInput-underline, &.MuiFilledInput-underline': {\n          '&::before, &::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          },\n          '&:hover': {\n            '&::before, &::after': {\n              borderColor: ({\n                options: {\n                  errorColor\n                }\n              }) => [style.getColor(errorColor), '!important']\n            }\n          },\n          '&.Mui-focused::before, &.Mui-focused::after, &.Mui-focused:hover::before, &.Mui-focused:hover::after': {\n            borderColor: ({\n              options: {\n                errorColor\n              }\n            }) => [style.getColor(errorColor), '!important']\n          }\n        }\n      }\n    }\n  };\n}","functions":["Clear","Enable","Disable","GetStoredObjectTrigger","GotStoredObject"],"triggers":["SetFilter","SetLocalStorage","GetStoredObject"],"interactions":{},"componentHash":"bce9e137b43aae1e3390c01b69eabab2496acc47e0ba3ac769ad0d83937ecaee"}]
